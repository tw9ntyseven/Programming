#include <iostream>
#include <vector>
#include <fstream>

std::ostream& operator<<(std::ostream& out, const std::vector<int>& vec)
{
    out << vec.size() << '\t' << '|' << '\t';

    for (int i = 0; i < vec.size(); i++)
    {
        out << &vec[i] << ' ';
    }
    out << '\n';
    return out;
}

//std::ostream& operator<<(std::ostream& out, const std::vector<int> vec)
//{
//    out << vec.size() << '\t' << '|' << '\t';
//
//    for (int i = 0; i < vec.size(); i++)
//    {
//        out << &vec[i] << ' ';
//    }
//    out << '\n';
//    return out;
//}

int main()
{
    const int N = 64;

    std::vector<int> vec;

    std::ofstream data("data.txt", std::ofstream::out | std::ofstream::trunc);
    
    for (int i = 0; i < N; i++)
    {
        vec.push_back(i);
        data << vec;
        std::cout << vec;
    }

    std::cout << "\n\n";
    
    for (int i = N - 1; i > 0; i--)
    {
        vec.pop_back();
        data << vec;
        std::cout << vec;
    }

    data.close();
    return 0;
}

/*
*
* Вопрос 1:
* Вектор состоит из элементов типа int.
* Проанализировав данные в файле data.txt мы видим, что элементы записаны с шагом в 4 байт, т. к. sizeof(int) == 4 байт
*
* Вопрос 2:
* Адрес может как меняться, так и оставаться неизменным. Это связано с тем, что мы заранее не знаем размер вектора.
* К примеру программист захочет добавить элемент. Представим кусочек памяти:
*
* | Busy | Empty | Empty | Busy |
*
* Если пользователь решит создать вектор и закинуть туда 1 элемент, то он сохранится во вторую ячейку памяти.
*
* Добавив второй элемент, он сохранится в третью ячейку (адрес нулевого останется неизменным).
*
* Добавив третий элемент, вектор переместится в другое место, где будет достаточно памяти для записи всех элементов (4 ячейка занята).
* Соответственно адрес нулевой ячейчи будет изменен
*
* Вопрос 3:
* Происходят аналогичные действия, которые расписаны в ответе на 1 вопрос
*
* Вопрос 4:
* Передавая вектор по значению, мы каждый раз создаем копию (хранится отдельно от исходного вектора и не имеет связи после передачи),
* но действия программы остаются неизменными (расписано в ответе на 1 вопрос)
*
*/
